# lec11: 进程／线程概念spoc练习

## 视频相关思考题

### 11.1 进程的概念

1. 什么是程序？什么是进程？

   > 程序是静态的可执行文件，进程是执行中的程序。进程是值一个有独立功能的程序在一个数据集合上的一次动态执行的过程。


2. 进程有哪些组成部分？

   进程控制块

   * 代码
   * 数据
   * 状态寄存器
   * 通用寄存器
   * 进程占用系统资源


3. 请举例说明进程的独立性和制约性的含义。
   - 独立性：不同进程之间不相互影响
   - 制约性：因访问共享数据/资源或进程间同步而产生制约


4. 程序和进程联系和区别是什么？
   - 联系：进程是操作系统处于执行状态程序的抽象
     - 程序：静态的可执行文件
     - 进程：程序+执行状态
   - 区别：同一个程序的多次执行应为不同的进程。进程有用户态和内核态的切换；进程是一个状态变换的过程。


### 11.2 进程控制块

1. 进程控制块的功能是什么？

   > 管理控制进程运行所用的信息集合，一个进程唯一地对应一个进程控制块（PCB）


2. 进程控制块中包括什么信息？

   > 1. 进程标识信息
   > 2. 处理机现场保存
   > 3. 进程控制信息
   >    - 调度和状态信息
   >    - 进程间通信信息
   >    - 存储管理信息
   >    - 进程所用资源


3. ucore的进展控制块数据结构定义中哪些字段？有什么作用？


### 11.3 进程状态

1. 进程生命周期中的相关事件有些什么？它们对应的进程状态变化是什么？

   > - 创建：
   >   - 系统初始化时
   >   - 用户请求创建一个新进程
   >   - 正在运行的进程执行了创建进程的系统调用
   > - 执行
   >   - 进程控制块进入队列，内核选择就绪的进程让他占用处理机并执行
   > - 等待
   >   - 运行时某个进程执行条件不成立，进程等待，可能是某个没有办法马上完成的状态或是需要的数据无法到达
   > - 抢占
   >   - 高优先级进程就绪或是进程执行时间片用完了，从运行态回到就绪态，让给其他进程。
   > - 唤醒
   >   - 被阻塞进程需要的资源可以被满足
   >   - 被阻塞进程等待的条件被满足
   > - 结束
   >   - 正常退出、错误退出
   >   - 致命错误（强制性）
   >   - 被其他进程杀掉了（强制性的）


### 11.4 三状态进程模型

1. 运行、就绪和等待三种状态的含义？7个状态转换事件的触发条件是什么？

   > 运行：进程正在处理机上运行。
   >
   > 就绪：进程获得了除处理机之外的所需资源，得到处理机即可运行。
   >
   > 等待：进程正在等待某一事件的出现。触发条件：
   >
   > 1. NULL->创建
   > 2. 创建->就绪：初始化完成
   > 3. 就绪->运行：选择一个就绪的进程给处理机
   > 4. 运行->结束：完成或出错时由操作系统回收
   > 5. 运行->就绪：处理机时间片用完让出处理机
   > 6. 运行->等待：要求某个还没有的资源
   > 7. 等待->就绪：等待的资源出现了


### 11.5 挂起进程模型

1. 引入挂起状态的目的是什么？

   > 减少进程占用内存，将挂起状态的进程映像在硬盘上

2. 引入挂起状态后，状态转换事件和触发条件有什么变化？

   > 1. 等待->等待挂起
   > 2. 就绪->就绪挂起：低优先级进程挪到硬盘。
   > 3. 运行->就绪挂起：抢先试分时系统，当高优先级等待挂起事件进入时触发。
   > 4. 激活
   >    1. 就绪挂起->就绪
   >    2. 等待挂起->等待

3. 内存中的什么内容放到外存中，就算是挂起状态？

   > 进程映像

### 11.6 线程的概念

1. 引入线程的目的是什么？

   > 希望在一个进程内还能进一步提高它的并发性。进程并发时希望进程可以隔离，和共享数据的要求有一定的矛盾，而且切换进程的开销大，所以希望能有一个更方便、轻量的并发机制，这种机制不那么重视隔离性。

2. 什么是线程？

   > 线程是进程的一部分，描述指令流执行状态。它是进程中的指令执行流的最小单元，是CPU调度的基本单位。

3. 进程与线程的联系和区别是什么？

   > 进程负责资源分配，线程成为了处理机调度的角色。
   >
   > 指令流调度交给线程。
   >
   > 进程拥有一个完整的资源平台，而线程只独享指令流执行必要的执行资源你，比如寄存器和栈。

### 11.7 用户线程

1. 什么是用户线程？

   > 在用户空间里通过函数库的方式实现线程的管理，包括线程的创建、终止、同步和调度。不依赖于操作系统的内核，同一进程内的用户线程切换块，但是当调用系统调用而阻塞时，整个进程进入等待。不支持基于线程的处理机抢占；只能按照进程分配CPU时间。

2. 用户线程的线程控制块保存在用户地址空间还是在内核地址空间？

   > 用户地址空间。


### 11.8 内核线程

1. 用户线程与内核线程的区别是什么？

   > 内核通过系统调用实现的线程机制，由内核负责维护PCB和TCB。
   >
   > 线程执行系统调用而被阻塞不影响其他线程，CPU调度的单位变成线程。

2. 同一进程内的不同线程可以共用一个相同的内核栈吗？

   > 可以。

3. 同一进程内的不同线程可以共用一个相同的用户栈吗？

   > 不可以。


## 选做题
1. 请尝试描述用户线程堆栈的可能维护方法。

## 小组思考题
(1) 熟悉和理解下面的简化进程管理系统中的进程状态变化情况。
 - [简化的三状态进程管理子系统使用帮助](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep7-process-run.md)
 - [简化的三状态进程管理子系统实现脚本](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep7-process-run.py)

(2) (spoc)设计一个简化的进程管理子系统，可以管理并调度如下简化进程。在理解[参考代码](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab4/process-concept-homework.py)的基础上，完成＂YOUR CODE"部分的内容。然后通过测试用例和比较自己的实现与往届同学的结果，评价自己的实现是否正确。可２个人一组。

### 进程的状态 

 - RUNNING - 进程正在使用CPU
 - READY   - 进程可使用CPU
 - DONE    - 进程结束

### 进程的行为
 - 使用CPU, 
 - 发出YIELD请求,放弃使用CPU


### 进程调度
 - 使用FIFO/FCFS：先来先服务,
   - 先查找位于proc_info队列的curr_proc元素(当前进程)之后的进程(curr_proc+1..end)是否处于READY态，
   - 再查找位于proc_info队列的curr_proc元素(当前进程)之前的进程(begin..curr_proc-1)是否处于READY态
   - 如都没有，继续执行curr_proc直到结束

### 关键模拟变量
 - 进程控制块
```
PROC_CODE = 'code_'
PROC_PC = 'pc_'
PROC_ID = 'pid_'
PROC_STATE = 'proc_state_'
```
 - 当前进程 curr_proc 
 - 进程列表：proc_info是就绪进程的队列（list），
 - 在命令行（如下所示）需要说明每进程的行为特征：（１）使用CPU ;(2)等待I/O
```
   -l PROCESS_LIST, --processlist= X1:Y1,X2:Y2,...
   X 是进程的执行指令数; 
   Ｙ是执行CPU的比例(0..100) ，如果是100，表示不会发出yield操作
```
 - 进程切换行为：系统决定何时(when)切换进程:进程结束或进程发出yield请求

### 进程执行
```
instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)
```

### 关键函数
 - 系统执行过程：run
 - 执行状态切换函数:　move_to_ready/running/done　
 - 调度函数：next_proc

### 执行实例

#### 例１
```
$./process-simulation.py -l 5:50
Process 0
  yld
  yld
  cpu
  cpu
  yld

Important behaviors:
  System will switch when the current process is FINISHED or ISSUES AN YIELD
Time     PID: 0 
  1     RUN:yld 
  2     RUN:yld 
  3     RUN:cpu 
  4     RUN:cpu 
  5     RUN:yld 

```


#### 例２
```
$./process-simulation.py  -l 5:50,5:50
Produce a trace of what would happen when you run these processes:
Process 0
  yld
  yld
  cpu
  cpu
  yld

Process 1
  cpu
  yld
  cpu
  cpu
  yld

Important behaviors:
  System will switch when the current process is FINISHED or ISSUES AN YIELD
Time     PID: 0     PID: 1 
  1     RUN:yld      READY 
  2       READY    RUN:cpu 
  3       READY    RUN:yld 
  4     RUN:yld      READY 
  5       READY    RUN:cpu 
  6       READY    RUN:cpu 
  7       READY    RUN:yld 
  8     RUN:cpu      READY 
  9     RUN:cpu      READY 
 10     RUN:yld      READY 
 11     RUNNING       DONE 
```
